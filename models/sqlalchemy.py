import enum
import typing
import settings
import operator
import sqlalchemy
import json
import attridict
from sqlalchemy.schema import CreateColumn
from sqlalchemy.ext.compiler import compiles
from datetime import datetime
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy_utils import database_exists, create_database, drop_database


DATABASE_CONNECTION_URL = settings.DATABASE_URL

if not database_exists(DATABASE_CONNECTION_URL):
    create_database(DATABASE_CONNECTION_URL)

engine = sqlalchemy.create_engine(DATABASE_CONNECTION_URL)
session = sqlalchemy.orm.Session(bind=engine)

FILTER_QUERIES = {
    'in': operator.contains,
    'contains': operator.contains,
    'eq': operator.eq,
    'gt': operator.gt,
    'gte': operator.ge,
    'lte': operator.le,
    'lt': operator.lt,
    'is_not': operator.is_not,
    'and': operator.and_,
    'or': operator.or_,
    'index': operator.indexOf,
}


@compiles(CreateColumn, 'postgresql')
def use_identity(element, compiler, **kw):
    text = compiler.visit_create_column(element, **kw)
    text = text.replace("SERIAL", "INT GENERATED BY DEFAULT AS IDENTITY")
    return text


def get_current_time():
    return datetime.now()


class SqlAlchemyModel(DeclarativeBase):
    """
    Базовая модель СУБД проекта
    """

    id = sqlalchemy.Column(
        sqlalchemy.BigInteger(),
        sqlalchemy.Identity(start=1, cycle=False),
        primary_key=True
    )

    def as_dict(self):
        instance_dict = self.__dict__.copy()
        instance_dict.pop('_sa_instance_state')

        return attridict.AttriDict(instance_dict)

    def __str__(self):
        return json.dumps(self.as_dict())

    def __repr__(self):
        return json.dumps(self.as_dict())

    def __json__(self):
        return self.as_dict()

    @classmethod
    def filter_field(cls, key, value):
        default_filter_name = 'eq'

        if key.count('__') > 1:
            raise RuntimeError(
                'Указано больше параметров, чем нужно'
            )

        if '__' not in key:
            filter_name = default_filter_name
        else:
            filter_input = key.split('__')
            filter_name = filter_input[-1]
            key = filter_input[0]

        if filter_name not in FILTER_QUERIES:
            raise RuntimeError(
                f'Фильтра "__{filter_name}" не существует.'
            )

        filter_func = FILTER_QUERIES[filter_name]
        return filter_func(getattr(cls, key), value)

    @classmethod
    def convert_kwargs(cls, **kwargs):
        new_filters = []

        for key, value in kwargs.items():
            new_filters.append(
                cls.filter_field(key, value)
            )

        return new_filters

    @classmethod
    def decompile_filters(cls, **filters):
        result = {}

        for key, val in filters.items():
            if '__' not in key:
                result[key] = val

            else:
                result[key.split('__')[0]] = val

        return result

    @classmethod
    def fetch_one(cls, *filters: typing.Callable, **kwargs: [str, typing.Any]) -> typing.Self:
        kwargs_filters = cls.convert_kwargs(**kwargs)

        query = session.execute(
            sqlalchemy.select(cls).where(*filters, *kwargs_filters).limit(1)
        )

        response = query.unique().fetchone()
        if not response:
            return None

        return response[0].as_dict()

    @classmethod
    def fetch_all(cls, *filters: typing.Callable, **kwargs: [str, typing.Any]) -> typing.List[typing.Self]:
        kwargs_filters = cls.convert_kwargs(**kwargs)

        query = session.execute(
            sqlalchemy.select(cls).where(*filters, *kwargs_filters)
        )

        result = query.unique().fetchall()
        return [row[0].as_dict() for row in result]

    @classmethod
    def create(cls, **kwargs) -> typing.Self:
        if 'id' in kwargs:
            kwargs.pop('id')

        result = session.execute(
            sqlalchemy.insert(cls).values(**kwargs)
        )

        session.commit()
        return cls.fetch_one(id=result.inserted_primary_key)

    @classmethod
    def fetch_or_create(cls, **kwargs: [str, typing.Any]) -> [typing.Self, bool]:
        data = cls.fetch_one(**kwargs)

        if not data:
            kwargs_decompiled = cls.decompile_filters(**kwargs)
            return [cls.create(**kwargs_decompiled), True]

        return [data, False]

    @classmethod
    def delete(cls,  *filters: typing.Callable, **kwargs: [str, typing.Any]) -> None:
        kwargs_filters = cls.convert_kwargs(**kwargs)

        session.execute(
            sqlalchemy.delete(cls).where(*filters, *kwargs_filters)
        )

        return session.commit()

    @classmethod
    def update(cls, row_id: int, **kwargs) -> typing.Self:
        filter_query = cls.convert_kwargs(id=row_id)

        query = session.execute(
            sqlalchemy.update(cls).where(*filter_query).values(**kwargs)
        )

        session.commit()
        return cls.fetch_one(id=query.lastrowid)


class DealStatuses(enum.Enum):
    """
    Enum'ы всех статусов сделки
    """

    CREATED = 'Сделка создана'
    PAID = 'Товар оплачен покупателем'
    PRODUCT_SUPPLIED = 'Товар отправлен продавцом'
    ARBITRATION = 'Идет спор'
    CANCELED_BY_SELLER = 'Сделка отменена продавцом'
    CANCELED_BY_CONSUMER = 'Сделка отменена покупателем'
    CLOSED_SUCCESSFULLY = 'Сделка успешно завершена'


class UserRoles(enum.Enum):
    """
    Enum'ы всех ролей пользователя
    """

    USER = 'пользователь'
    ADMIN = 'администратор'
    MODERATOR = 'модератор'
    SUPPORT = 'тех.поддержка'


class User(SqlAlchemyModel):
    """
    Модель пользователя БД
    """

    __tablename__ = 'users'

    email = sqlalchemy.Column(
        sqlalchemy.VARCHAR(255),
        nullable=False,
        name='email'
    )

    password_hash = sqlalchemy.Column(
        sqlalchemy.VARCHAR(1000),
        nullable=False,
        name='passwordHash'
    )

    first_name = sqlalchemy.Column(
        sqlalchemy.VARCHAR(50),
        nullable=False,
        name='firstName'
    )

    last_name = sqlalchemy.Column(
        sqlalchemy.VARCHAR(50),
        nullable=True,
        name='lastName'
    )

    date_joined = sqlalchemy.Column(
        sqlalchemy.DateTime(),
        nullable=False,
        default=datetime.now,
        name='dateJoined'
    )

    date_password_changed = sqlalchemy.Column(
        sqlalchemy.DateTime(),
        nullable=True,
        default=datetime.now,
        name='datePasswordChanged'
    )

    email_verified = sqlalchemy.Column(
        sqlalchemy.Boolean(),
        nullable=False,
        default=False,
        name='emailVerified'
    )

    role: sqlalchemy.orm.Mapped[UserRoles] = sqlalchemy.orm.mapped_column(
        default=UserRoles.USER
    )


class Product(SqlAlchemyModel):
    """
    Модель товара БД
    """

    __tablename__ = 'products'

    seller_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey('users.id'),
        nullable=False,
        name='sellerId'
    )

    seller = sqlalchemy.orm.relationship(
        'User',
        lazy='immediate',
        backref=sqlalchemy.orm.backref('products')
    )

    title = sqlalchemy.Column(
        sqlalchemy.VARCHAR(256),
        nullable=False,
        name='title'
    )

    description = sqlalchemy.Column(
        sqlalchemy.Text(),
        nullable=True,
        name='description'
    )

    attachments = sqlalchemy.Column(
        sqlalchemy.ARRAY(
            sqlalchemy.VARCHAR(255)
        ),
        name='attachments'
    )

    price = sqlalchemy.Column(
        sqlalchemy.Integer(),
        name='price'
    )

    quantity_available = sqlalchemy.Column(
        sqlalchemy.Integer(),
        name='quantityAvailable'
    )


class Deal(SqlAlchemyModel):
    """
    Модель сделки БД
    """

    __tablename__ = 'deals'

    seller_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey('users.id'),
        nullable=False,
        name='sellerId',
    )

    seller = sqlalchemy.orm.relationship(
        'User',
        lazy='immediate',
        foreign_keys=seller_id
    )

    consumer_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey('users.id'),
        nullable=False,
        name='consumerId',
    )

    consumer = sqlalchemy.orm.relationship(
        'User',
        lazy='immediate',
        foreign_keys=consumer_id
    )

    product_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey('products.id'),
        nullable=False
    )

    product = sqlalchemy.orm.relationship(
        'Product',
        lazy='immediate',
        backref=sqlalchemy.orm.backref(
            'deals'
        ),
        foreign_keys=product_id
    )

    quantity = sqlalchemy.Column(
        sqlalchemy.Integer(),
        nullable=False,
        default=1
    )

    status: sqlalchemy.orm.Mapped[DealStatuses] = sqlalchemy.orm.mapped_column(
        default=DealStatuses.CREATED
    )


class DealMessage(SqlAlchemyModel):
    """
    Модель сообщения для обмена между участниками сделки
    """

    __tablename__ = 'deal_messages'

    from_user_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey('users.id'),
        nullable=False,
        name='fromUserId'
    )

    from_user = sqlalchemy.orm.relationship(
        'User',
        lazy='immediate',
        backref=sqlalchemy.orm.backref(
            'deal_messages'
        )
    )

    message = sqlalchemy.Column(
        sqlalchemy.VARCHAR(
            length=256
        ),
        nullable=False,
        name='message'
    )

    deal_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey('deals.id'),
        nullable=False,
        name='dealId'
    )

    deal = sqlalchemy.orm.relationship(
        'Deal',
        lazy='immediate'
    )

    attachments = sqlalchemy.Column(
        sqlalchemy.ARRAY(
            sqlalchemy.VARCHAR(255)
        ),
        nullable=True,
        name='attachments'
    )


SqlAlchemyModel.metadata.create_all(bind=engine)
